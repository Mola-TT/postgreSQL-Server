---
description: 
globs: 
alwaysApply: true
---
# Milestone

## Milestone 9 (In Progress)
- Create `disaster_recovery.sh` under setup folder that:
  - Implements automated system recovery procedures after unexpected reboots
  - Configures service auto-restart mechanisms for all critical components
  - Implements database recovery protocols for handling software freezes
  - Creates watchdog services to monitor and automatically recover failed components
  - Implements transaction journaling to prevent data loss during crashes
  - Configures proper service dependencies to ensure correct startup order
  - Implements recovery verification to ensure all services return to proper state
  - Creates failover mechanisms for handling unexpected situations
- Create recovery management scripts:
  - Script to test recovery procedures in a controlled environment
  - Script to simulate various disaster scenarios for testing
  - Script to analyze system logs after recovery for post-mortem assessment
  - Script to verify system integrity after recovery events
- Create comprehensive test script (`test_disaster_recovery.sh`) to validate:
  - System reboot recovery procedures
  - PostgreSQL crash recovery
  - pgbouncer failure and recovery
  - Nginx failure and recovery
  - Netdata monitoring during recovery events
  - Email notifications for recovery events
- Create specialized test scripts for recovery scenarios:
  - `test_system_reboot.sh` to validate automatic service restoration after reboot
  - `test_service_failure.sh` to simulate and validate recovery from service crashes
  - `test_database_corruption.sh` to validate data integrity protection mechanisms
  - `test_network_disruption.sh` to simulate and recover from network failures
  - `test_disk_failure.sh` to validate recovery from storage subsystem issues
  - `test_resource_exhaustion.sh` to test recovery from memory/CPU/disk space depletion
- Update environment configuration:
  - Add recovery-specific settings to default.env and user.env.template
  - Add recovery timeout configuration
  - Add recovery notification settings
  - Add recovery verification thresholds
- Implement recovery monitoring:
  - Add Netdata dashboard for recovery status monitoring
  - Create health checks for recovery systems
  - Implement recovery time metrics and monitoring
  - Add recovery failure alerting

## Milestone 8 (Completed)
- Created `pg_user_monitor.sh` under setup folder that:
  - Implements automatic PostgreSQL user synchronization with pgbouncer userlist
  - Monitors PostgreSQL user changes in real-time (creation, deletion, password changes)
  - Automatically updates pgbouncer userlist.txt with SCRAM-SHA-256 password hashes
  - Runs as a systemd service with configurable monitoring intervals
  - Handles user login privilege changes (excludes NOLOGIN users from userlist)
  - Provides robust error handling and graceful fallback mechanisms
  - Implements atomic file operations to prevent userlist corruption
  - Generates clean userlist files without comment headers (pgbouncer compatibility)
  - Supports JSON-based state management for change detection
  - Includes automatic pgbouncer reload after userlist updates
- Enhanced pgbouncer userlist management:
  - Resolved pgbouncer "broken auth file" errors caused by comment headers
  - Implemented proper file permissions (600) for enhanced security
  - Added duplicate entry prevention and cleanup mechanisms
  - Ensured consistent SCRAM-SHA-256 password hash format
  - Fixed authentication issues that caused "SASL authentication failed" errors
- Created comprehensive test script (`test_pg_user_monitor.sh`) to validate:
  - Service installation and systemd integration
  - User creation, modification, and deletion detection
  - Password change synchronization
  - Non-login user handling (proper exclusion from userlist)
  - pgbouncer reload functionality
  - Log file creation and state file management
  - Service restart and recovery capabilities
- Updated environment configuration:
  - Added PostgreSQL user monitor settings to default.env and user.env.template
  - Added configurable monitoring interval (PG_USER_MONITOR_INTERVAL)
  - Added log path configuration (PG_USER_MONITOR_LOG_PATH)
  - Added service name configuration for flexibility
- Enhanced connection testing:
  - Fixed temporary user authentication tests in test_pg_connection.sh
  - Resolved IPv6 vs IPv4 connectivity issues
  - Implemented comprehensive SSL mode testing (require, prefer, allow, disable)
  - Added proper cleanup and service management during tests
  - Removed verbose debug output for cleaner test logs
- Improved system integration:
  - Updated init.sh to include PostgreSQL user monitor setup
  - Integrated with existing backup, monitoring, and optimization systems
  - Ensured compatibility with all previous milestone features
  - Added proper service dependencies and startup ordering

## Milestone 7 (Completed)
- Created `backup_config.sh` under setup folder that:
  - Implemented automated PostgreSQL database backups
  - Configured rotational backup strategy with daily, weekly, and monthly retention
  - Set up incremental and full backup schedules
  - Implemented backup compression to minimize storage requirements
  - Configured secure backup storage with proper permissions
  - Created email notifications for backup success/failure
  - Implemented backup verification to ensure data integrity
  - Added backup encryption options for sensitive data
- Created backup management scripts:
  - Script to list available backups (`list_backups.sh`)
  - Script to restore from specific backup points (`restore_backup.sh`)
  - Script to verify backup integrity (`verify_integrity.sh`)
  - Script to manage backup retention policies (`manage_retention.sh`)
- Created comprehensive test script (`test_backup.sh`) to validate:
  - Backup creation and scheduling
  - Backup rotation and retention
  - Backup compression and encryption
  - Backup restoration process
  - Email notifications for backup events
- Updated environment configuration:
  - Added backup-specific settings to default.env and user.env.template
  - Added backup schedule configuration
  - Added backup retention policy settings
  - Added backup location configuration
  - Added backup encryption settings
- Implemented backup monitoring:
  - Added Netdata dashboard for backup status
  - Created backup health checks
  - Implemented backup size and growth monitoring
  - Added backup failure alerting

## Milestone 6 (Completed)
- Create `dynamic_optimization.sh` under setup folder that:
  - Detects hardware specifications (CPU cores, memory, disk size)
  - Dynamically calculates optimal PostgreSQL configuration parameters
  - Dynamically calculates optimal pgbouncer configuration parameters
  - Implements intelligent resource allocation based on available hardware
  - Provides performance recommendations based on workload patterns
  - Creates monitoring hooks to detect performance bottlenecks
- Create `hardware_change_detector.sh` under setup folder that:
  - Implements a service to monitor for hardware changes (CPU, RAM, disk)
  - Triggers automatic reconfiguration when hardware changes are detected
  - Records previous vs. new hardware specifications for comparison
  - Performs gradual/phased optimization during production hours
  - Creates backup of previous configuration before applying changes
  - Implements robust email notification system for hardware changes
  - Provides multiple fallback methods for PostgreSQL data directory detection
  - Includes test email functionality to verify email configuration
- Update PostgreSQL configuration for dynamic scaling:
  - Implement dynamic shared_buffers sizing (percentage of total RAM)
  - Configure work_mem based on available memory and connection count
  - Adjust effective_cache_size based on total system memory
  - Optimize max_connections based on available CPU and memory
  - Configure maintenance_work_mem for optimal vacuum performance
  - Implement dynamic checkpoint configuration
  - Tune WAL settings based on disk I/O capabilities
- Update pgbouncer configuration for dynamic scaling:
  - Dynamically adjust default_pool_size based on CPU cores
  - Calculate optimal max_client_conn based on system resources
  - Implement dynamic reserve_pool_size calculation
  - Configure connection pooling strategy based on workload analysis
  - Optimize pool_mode selection based on application query patterns
- Create comprehensive test script (`test_dynamic_optimization.sh`) to validate:
  - Correct parameter calculations for different hardware profiles
  - Proper configuration file generation and application
  - Performance improvements after optimization
  - Correct behavior during hardware change simulations
  - Resource utilization before and after optimization
- Create comprehensive test script (`test_email_notification.sh`) to validate:
  - Email notifications for hardware changes
  - Email notifications for optimization completion
  - Basic test email functionality
  - Proper email tool installation and configuration
  - Fallback mechanisms for email sending
- Create analytics and reporting for optimization:
  - Generate optimization reports with before/after comparisons
  - Visualize performance metrics through Netdata dashboards
  - Implement predictive analysis for future resource needs
  - Create alerting system for approaching resource limits
  - Document optimization decisions and rationale
- Enhanced environment configuration:
  - Added email notification settings to environment files
  - Added TEST_EMAIL_SUBJECT variable for email testing
  - Implemented backward compatibility with Netdata email settings
  - Unified email configuration across different components

## Milestone 5
- Created `ssl_renewal.sh` under setup folder that:
  - Set up automatic renewal of Let's Encrypt SSL certificates
  - Configured proper renewal hooks to restart/reload necessary services after renewal
  - Implemented fallback mechanisms for when renewal might fail
  - Created detailed logging for renewal processes
  - Ensured proper file permissions for certificate files
  - Included graceful error handling with clear error messages
  - Configured different certificate renewal approaches based on validation method (HTTP vs DNS)
  - Added special handling for DNS propagation delays in Cloudflare DNS validation
  - Implemented non-production mode with minimal renewal reminders when certbot isn't available
- Created comprehensive test script (`test_ssl_renewal.sh`) to validate:
  - Proper certificate renewal configuration (without actually performing renewal)
  - Renewal hooks functionality
  - Proper permissions on SSL certificate files
  - Simulated renewal process with dry-run
  - Log file creation and error reporting
  - Added specific handling for non-production environments
  - Provided detailed diagnostics for renewal simulation failures
- Updated init.sh and logger.sh:
  - Added SSL renewal configuration in the initialization process
  - Enhanced logging with green PASS output for test successes
  - Improved output formatting with consistent timestamps and spacing
  - Added empty lines between test sections for improved readability
- Enhanced error handling and logging:
  - Implemented detailed error reporting for renewal failures
  - Added verification steps for renewal configuration
  - Created troubleshooting guidance in log messages
  - Added validation checks to prevent common renewal issues
  - Suppressed SQL command outputs to keep logs clean and focused
  - Created helper functions for executing PostgreSQL commands silently
- Fixed bugs and improved robustness:
  - Fixed Let's Encrypt certificate handling with PRODUCTION=false environments
  - Added robust certbot installation with retry logic and verification
  - Enhanced test sequence to ensure proper dependencies between tests
  - Increased DNS propagation delay time for Cloudflare validation from 10s to 60s
  - Tagged code with Milestone_5 for version control and release management

## Milestone 4
- Created `netdata_config.sh` under setup folder that:
  - Installs Netdata for system resource monitoring
  - Configures Netdata to listen only on localhost for security
  - Sets up Nginx as a secure HTTPS proxy for Netdata dashboard access
  - Implements basic authentication for Netdata web interface
  - Configures SSL using Let's Encrypt certificates with proper staging/production environment support
  - Creates health alert notifications for CPU, RAM, and disk usage thresholds at 80%
  - Configures email alerts when system resources exceed thresholds
  - Configures firewall rules to block direct access to Netdata port (19999)
- Created comprehensive test script (`test_netdata.sh`) to validate:
  - Internal Netdata accessibility on localhost
  - External Netdata accessibility via HTTPS proxy
  - Authentication with proper credentials
  - HTTP to HTTPS redirection
  - Firewall configuration blocking direct access
- Enhanced environment configuration:
  - Added Netdata-specific settings to environment files
  - Added email notification configuration options
  - Added PRODUCTION flag to control Let's Encrypt staging vs production environments
  - Added secure credential storage mechanisms
- Improved error handling and logging:
  - Implemented detailed error reporting for certificate acquisition failures
  - Added proper service status verification
  - Fixed configuration bugs related to WebSocket support
  - Added troubleshooting guidance in log messages

## Milestone 3
- Created `nginx_config.sh` under setup folder to:
  - Install and configure Nginx as a secure proxy for PostgreSQL
  - Configure SSL using Let's Encrypt with fallback to self-signed certificates
  - Implement automatic subdomain-to-database mapping (e.g., bestdb.domain.com connects to bestdb database)
  - Configure firewall rules to expose Nginx ports (80/443) while restricting direct PostgreSQL access
  - Update pgbouncer configuration for wildcard database handling
  - Ensure all connections to PostgreSQL are secured with SSL through port 6432 via pgbouncer
  - Provide robust error handling and silent installation
- Updated `init.sh` to include Nginx configuration in the initialization process
- Enhanced environment configuration:
  - Added Nginx-specific settings to default.env and user.env.template
  - Added SSL certificate configuration options
  - Added domain name configuration for subdomain mapping

## Milestone 2
- Restructured project for better organization:
  - Moved utility scripts to `lib/` directory
  - Moved configuration files to `conf/` directory
  - Updated all file references to match the new structure
- Created `postgresql_config.sh` under setup folder that:
  - Installs PostgreSQL using the official repository
  - Installs pgbouncer for connection pooling
  - Configures PostgreSQL with proper security settings:
    - Uses secure scram-sha-256 authentication instead of md5
    - Restricts direct PostgreSQL access to local connections only
    - Routes all external connections through pgbouncer
    - Configures firewall to enforce this connection policy
  - Sets up pgbouncer as middleware:
    - Uses a simplified, reliable configuration approach
    - Implements robust configuration verification without error messages
    - Includes automatic fallback to simpler configuration if needed
    - Features multiple verification methods for password hash extraction
  - Creates user-specified database
  - Configures client authentication based on user-defined IP ranges
  - Sets and secures PostgreSQL superuser password
  - Uses environment variables for all configuration settings
- Updated `init.sh` to include PostgreSQL installation and configuration
- Enhanced environment configuration:
  - Added PostgreSQL-specific settings to default.env and user.env.template
  - Added pgbouncer configuration settings
  - Added PostgreSQL superuser password management
  - Added SYSTEM_UPDATE and RUN_TESTS environment variables
  - Improved timezone configuration with proper variable handling
  - Set timezone to Asia/Hong_Kong
  - Enabled automatic test execution
- Improved logging and error handling:
  - Ensured clean, error-free logs during normal operation
  - Implemented graceful fallback mechanisms for configuration issues
  - Added verification steps for all critical components
  - Fixed timezone error by properly handling timezone variables
  - Added backward compatibility for legacy variable references

## Milestone 1
- Created an `init.sh` script that:
  - Updates the Ubuntu server silently
  - Sets up timezone directly from configuration
  - Checks if running as root
  - Loads environment variables
  - Provides proper initialization flow
- Created a `logger.sh` script with logging functions:
  - Implemented color-coded log levels (DEBUG, INFO, WARNING, ERROR)
  - Made log message timestamps bold
  - Made log messages white by default
  - Applied colors only to log level text
  - Added file logging capability
- Created environment configuration:
  - Added `default.env` with default configuration
  - Added `user.env.template` for user-specific settings
  - Implemented environment variable override logic
- Added utility functions:
  - Created `utilities.sh` with helper functions
  - Implemented `execute_silently` for quiet command execution
  - Added log file management
- Created general configuration:
  - Added system update functionality
  - Added timezone configuration



