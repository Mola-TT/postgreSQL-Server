---
description: 
globs: 
alwaysApply: true
---
# Milestone

## Milestone 12 (In Progress)
- (Future enhancements to be defined)

## Milestone 11 (Completed)
- Created `security_config.sh` under setup folder that:
  - Implements fail2ban for automated IP blocking based on attack patterns
  - Sets up geographic IP filtering to block traffic from high-risk countries
  - Adds proper Web Application Firewall (WAF) with nginx rate limiting
  - Configures DDoS protection and attack traffic mitigation
  - Implements comprehensive security logging and monitoring
  - Adds IP reputation-based blocking and whitelist management
  - Configures automated security incident response and alerting
  - Enhances nginx security headers and SSL/TLS hardening
  - Implements request rate limiting and burst protection
  - Adds security audit logging for all access attempts
- Enhanced fail2ban configuration:
  - Configured protection for SSH, Nginx, and PostgreSQL services
  - Implemented custom filters for nginx bad bots and bot searches
  - Added PostgreSQL authentication failure detection
  - Configured email notifications for security events
  - Set up automatic IP banning with configurable timeouts
- Geographic IP blocking system:
  - Implemented GeoIP database integration for country-based blocking
  - Created automated blocking script for high-risk countries
  - Added ipset-based IP range management for efficient blocking
  - Configured systemd service for persistent geo-blocking
- Advanced nginx security features:
  - Added security headers (X-Frame-Options, CSP, HSTS, etc.)
  - Implemented user agent filtering and request pattern blocking
  - Added protection against common web exploits and SQL injection
  - Configured rate limiting and connection throttling
  - Added CloudFlare real IP configuration for proxy setups
- Comprehensive security monitoring:
  - Created automated security monitoring script with alerting
  - Implemented detection for suspicious nginx activity patterns
  - Added SSH login failure monitoring and alerting
  - Configured fail2ban ban status monitoring
  - Set up automated security event logging and email notifications
- Updated init.sh integration:
  - Added security configuration to main initialization process
  - Implemented configurable security feature enablement
  - Added comprehensive setup status reporting
  - Ensured graceful fallback if security setup encounters issues

## Milestone 10 (Completed)
- Created `create_database.sh` under tools folder that:
  - Automates the creation of new PostgreSQL databases with dedicated admin users
  - Implements interactive prompts for database creation credentials
  - Uses createdb command for database creation: `createdb -d "name_of_database"`
  - Creates database-specific admin users with restricted access
  - Ensures proper privilege isolation between databases
  - Provides secure user management within database scope
- Interactive credential prompts:
  - PostgreSQL superuser username
  - PostgreSQL superuser password  
  - Database name to create
  - Password for new admin user (default username: `<database_name>_admin`)
- Database admin user configuration:
  - Create admin user with access only to the newly created database
  - Grant full privileges (CREATE, CONNECT, TEMP, etc.) on target database
  - Enable admin to create users within the specific database only
  - Restrict admin from accessing or viewing other databases through PUBLIC role privilege management
  - Prevent admin from creating users with elevated privileges
- User management by database admin:
  - Users created by admin can only access the specific database
  - Created users cannot create other users
  - Users inherit rights from admin, scoped to database only
  - Implement proper role hierarchy and privilege inheritance
- Testing and validation:
  - Integrated comprehensive testing within the same `create_database.sh` script (8 test scenarios)
  - Test admin user privilege restrictions and scope after creation
  - Verify user creation capabilities and limitations
  - Test database isolation and access controls
  - Validate proper privilege inheritance for created users
- Security and compliance:
  - Implemented secure credential handling during interactive prompts
  - Ensured proper role-based access control (RBAC)
  - Validated database privilege isolation by revoking PUBLIC CONNECT privileges
  - Created audit logging for database and user creation activities
- Advanced privilege management:
  - Fixed database isolation by identifying and addressing PUBLIC role privileges
  - Implemented NOINHERIT flag to prevent default role inheritance
  - Added comprehensive privilege revocation and selective re-granting
  - Maintained system functionality while enforcing strict database isolation

## Milestone 9 (Completed)
- Created `disaster_recovery.sh` under setup folder that:
  - Implements automated system recovery procedures after unexpected reboots
  - Configures service auto-restart mechanisms for all critical components (postgresql, pgbouncer, nginx, netdata, pg-user-monitor)
  - Implements database recovery protocols for handling software freezes
  - Creates watchdog services to monitor and automatically recover failed components
  - Implements transaction journaling to prevent data loss during crashes via JSON state management
  - Configures proper service dependencies to ensure correct startup order
  - Implements recovery verification to ensure all services return to proper state
  - Creates failover mechanisms for handling unexpected situations with email notifications
- Created recovery management scripts:
  - `test_recovery_procedures.sh` to test recovery procedures in a controlled environment
  - `simulate_disaster_scenarios.sh` to simulate various disaster scenarios for testing
  - Scripts analyze system logs after recovery for post-mortem assessment via state file management
  - Scripts verify system integrity after recovery events through comprehensive health checks
- Created comprehensive test script (`test_disaster_recovery.sh`) to validate:
  - System reboot recovery procedures
  - PostgreSQL crash recovery
  - pgbouncer failure and recovery
  - Nginx failure and recovery
  - Netdata monitoring during recovery events
  - Email notifications for recovery events
- Created specialized test scripts for recovery scenarios:
  - `test_system_reboot.sh` to validate automatic service restoration after reboot
  - `test_service_failure.sh` to simulate and validate recovery from service crashes
  - Recovery procedures script to validate data integrity protection mechanisms
  - Simulation script to simulate and recover from network disruptions
  - Recovery monitoring for disk and resource exhaustion scenarios
- Updated environment configuration:
  - Added recovery-specific settings to default.env and user.env.template
  - Added recovery timeout configuration (DISASTER_RECOVERY_TIMEOUT)
  - Added recovery notification settings (DISASTER_RECOVERY_EMAIL_*)
  - Added recovery verification thresholds and check intervals
- Implemented recovery monitoring:
  - Added systemd service integration for recovery status monitoring
  - Created comprehensive health checks for recovery systems
  - Implemented recovery time metrics and state management via JSON logging
  - Added recovery failure alerting through email notification system

## Milestone 8 (Completed)
- Created `pg_user_monitor.sh` under setup folder that:
  - Implements automatic PostgreSQL user synchronization with pgbouncer userlist
  - Monitors PostgreSQL user changes in real-time (creation, deletion, password changes)
  - Automatically updates pgbouncer userlist.txt with SCRAM-SHA-256 password hashes
  - Runs as a systemd service with configurable monitoring intervals
  - Handles user login privilege changes (excludes NOLOGIN users from userlist)
  - Provides robust error handling and graceful fallback mechanisms
  - Implements atomic file operations to prevent userlist corruption
  - Generates clean userlist files without comment headers (pgbouncer compatibility)
  - Supports JSON-based state management for change detection
  - Includes automatic pgbouncer reload after userlist updates
- Enhanced pgbouncer userlist management:
  - Resolved pgbouncer "broken auth file" errors caused by comment headers
  - Implemented proper file permissions (600) for enhanced security
  - Added duplicate entry prevention and cleanup mechanisms
  - Ensured consistent SCRAM-SHA-256 password hash format
  - Fixed authentication issues that caused "SASL authentication failed" errors
- Created comprehensive test script (`test_pg_user_monitor.sh`) to validate:
  - Service installation and systemd integration
  - User creation, modification, and deletion detection
  - Password change synchronization
  - Non-login user handling (proper exclusion from userlist)
  - pgbouncer reload functionality
  - Log file creation and state file management
  - Service restart and recovery capabilities
- Updated environment configuration:
  - Added PostgreSQL user monitor settings to default.env and user.env.template
  - Added configurable monitoring interval (PG_USER_MONITOR_INTERVAL)
  - Added log path configuration (PG_USER_MONITOR_LOG_PATH)
  - Added service name configuration for flexibility
- Enhanced connection testing:
  - Fixed temporary user authentication tests in test_pg_connection.sh
  - Resolved IPv6 vs IPv4 connectivity issues
  - Implemented comprehensive SSL mode testing (require, prefer, allow, disable)
  - Added proper cleanup and service management during tests
  - Removed verbose debug output for cleaner test logs
- Improved system integration:
  - Updated init.sh to include PostgreSQL user monitor setup
  - Integrated with existing backup, monitoring, and optimization systems
  - Ensured compatibility with all previous milestone features
  - Added proper service dependencies and startup ordering

## Milestone 7 (Completed)
- Created `backup_config.sh` under setup folder that:
  - Implemented automated PostgreSQL database backups
  - Configured rotational backup strategy with daily, weekly, and monthly retention
  - Set up incremental and full backup schedules
  - Implemented backup compression to minimize storage requirements
  - Configured secure backup storage with proper permissions
  - Created email notifications for backup success/failure
  - Implemented backup verification to ensure data integrity
  - Added backup encryption options for sensitive data
- Created backup management scripts:
  - Script to list available backups (`list_backups.sh`)
  - Script to restore from specific backup points (`restore_backup.sh`)
  - Script to verify backup integrity (`verify_integrity.sh`)
  - Script to manage backup retention policies (`manage_retention.sh`)
- Created comprehensive test script (`test_backup.sh`) to validate:
  - Backup creation and scheduling
  - Backup rotation and retention
  - Backup compression and encryption
  - Backup restoration process
  - Email notifications for backup events
- Updated environment configuration:
  - Added backup-specific settings to default.env and user.env.template
  - Added backup schedule configuration
  - Added backup retention policy settings
  - Added backup location configuration
  - Added backup encryption settings
- Implemented backup monitoring:
  - Added Netdata dashboard for backup status
  - Created backup health checks
  - Implemented backup size and growth monitoring
  - Added backup failure alerting

## Milestone 6 (Completed)
- Create `dynamic_optimization.sh` under setup folder that:
  - Detects hardware specifications (CPU cores, memory, disk size)
  - Dynamically calculates optimal PostgreSQL configuration parameters
  - Dynamically calculates optimal pgbouncer configuration parameters
  - Implements intelligent resource allocation based on available hardware
  - Provides performance recommendations based on workload patterns
  - Creates monitoring hooks to detect performance bottlenecks
- Create `hardware_change_detector.sh` under setup folder that:
  - Implements a service to monitor for hardware changes (CPU, RAM, disk)
  - Triggers automatic reconfiguration when hardware changes are detected
  - Records previous vs. new hardware specifications for comparison
  - Performs gradual/phased optimization during production hours
  - Creates backup of previous configuration before applying changes
  - Implements robust email notification system for hardware changes
  - Provides multiple fallback methods for PostgreSQL data directory detection
  - Includes test email functionality to verify email configuration
- Update PostgreSQL configuration for dynamic scaling:
  - Implement dynamic shared_buffers sizing (percentage of total RAM)
  - Configure work_mem based on available memory and connection count
  - Adjust effective_cache_size based on total system memory
  - Optimize max_connections based on available CPU and memory
  - Configure maintenance_work_mem for optimal vacuum performance
  - Implement dynamic checkpoint configuration
  - Tune WAL settings based on disk I/O capabilities
- Update pgbouncer configuration for dynamic scaling:
  - Dynamically adjust default_pool_size based on CPU cores
  - Calculate optimal max_client_conn based on system resources
  - Implement dynamic reserve_pool_size calculation
  - Configure connection pooling strategy based on workload analysis
  - Optimize pool_mode selection based on application query patterns
- Create comprehensive test script (`test_dynamic_optimization.sh`) to validate:
  - Correct parameter calculations for different hardware profiles
  - Proper configuration file generation and application
  - Performance improvements after optimization
  - Correct behavior during hardware change simulations
  - Resource utilization before and after optimization
- Create comprehensive test script (`test_email_notification.sh`) to validate:
  - Email notifications for hardware changes
  - Email notifications for optimization completion
  - Basic test email functionality
  - Proper email tool installation and configuration
  - Fallback mechanisms for email sending
- Create analytics and reporting for optimization:
  - Generate optimization reports with before/after comparisons
  - Visualize performance metrics through Netdata dashboards
  - Implement predictive analysis for future resource needs
  - Create alerting system for approaching resource limits
  - Document optimization decisions and rationale
- Enhanced environment configuration:
  - Added email notification settings to environment files
  - Added TEST_EMAIL_SUBJECT variable for email testing
  - Implemented backward compatibility with Netdata email settings
  - Unified email configuration across different components

## Milestone 5
- Created `ssl_renewal.sh` under setup folder that:
  - Set up automatic renewal of Let's Encrypt SSL certificates
  - Configured proper renewal hooks to restart/reload necessary services after renewal
  - Implemented fallback mechanisms for when renewal might fail
  - Created detailed logging for renewal processes
  - Ensured proper file permissions for certificate files
  - Included graceful error handling with clear error messages
  - Configured different certificate renewal approaches based on validation method (HTTP vs DNS)
  - Added special handling for DNS propagation delays in Cloudflare DNS validation
  - Implemented non-production mode with minimal renewal reminders when certbot isn't available
- Created comprehensive test script (`test_ssl_renewal.sh`) to validate:
  - Proper certificate renewal configuration (without actually performing renewal)
  - Renewal hooks functionality
  - Proper permissions on SSL certificate files
  - Simulated renewal process with dry-run
  - Log file creation and error reporting
  - Added specific handling for non-production environments
  - Provided detailed diagnostics for renewal simulation failures
- Updated init.sh and logger.sh:
  - Added SSL renewal configuration in the initialization process
  - Enhanced logging with green PASS output for test successes
  - Improved output formatting with consistent timestamps and spacing
  - Added empty lines between test sections for improved readability
- Enhanced error handling and logging:
  - Implemented detailed error reporting for renewal failures
  - Added verification steps for renewal configuration
  - Created troubleshooting guidance in log messages
  - Added validation checks to prevent common renewal issues
  - Suppressed SQL command outputs to keep logs clean and focused
  - Created helper functions for executing PostgreSQL commands silently
- Fixed bugs and improved robustness:
  - Fixed Let's Encrypt certificate handling with PRODUCTION=false environments
  - Added robust certbot installation with retry logic and verification
  - Enhanced test sequence to ensure proper dependencies between tests
  - Increased DNS propagation delay time for Cloudflare validation from 10s to 60s
  - Tagged code with Milestone_5 for version control and release management

## Milestone 4
- Created `netdata_config.sh` under setup folder that:
  - Installs Netdata for system resource monitoring
  - Configures Netdata to listen only on localhost for security
  - Sets up Nginx as a secure HTTPS proxy for Netdata dashboard access
  - Implements basic authentication for Netdata web interface
  - Configures SSL using Let's Encrypt certificates with proper staging/production environment support
  - Creates health alert notifications for CPU, RAM, and disk usage thresholds at 80%
  - Configures email alerts when system resources exceed thresholds
  - Configures firewall rules to block direct access to Netdata port (19999)
- Created comprehensive test script (`test_netdata.sh`) to validate:
  - Internal Netdata accessibility on localhost
  - External Netdata accessibility via HTTPS proxy
  - Authentication with proper credentials
  - HTTP to HTTPS redirection
  - Firewall configuration blocking direct access
- Enhanced environment configuration:
  - Added Netdata-specific settings to environment files
  - Added email notification configuration options
  - Added PRODUCTION flag to control Let's Encrypt staging vs production environments
  - Added secure credential storage mechanisms
- Improved error handling and logging:
  - Implemented detailed error reporting for certificate acquisition failures
  - Added proper service status verification
  - Fixed configuration bugs related to WebSocket support
  - Added troubleshooting guidance in log messages

## Milestone 3
- Created `nginx_config.sh` under setup folder to:
  - Install and configure Nginx as a secure proxy for PostgreSQL
  - Configure SSL using Let's Encrypt with fallback to self-signed certificates
  - Implement automatic subdomain-to-database mapping (e.g., bestdb.domain.com connects to bestdb database)
  - Configure firewall rules to expose Nginx ports (80/443) while restricting direct PostgreSQL access
  - Update pgbouncer configuration for wildcard database handling
  - Ensure all connections to PostgreSQL are secured with SSL through port 6432 via pgbouncer
  - Provide robust error handling and silent installation
- Updated `init.sh` to include Nginx configuration in the initialization process
- Enhanced environment configuration:
  - Added Nginx-specific settings to default.env and user.env.template
  - Added SSL certificate configuration options
  - Added domain name configuration for subdomain mapping

## Milestone 2
- Restructured project for better organization:
  - Moved utility scripts to `lib/` directory
  - Moved configuration files to `conf/` directory
  - Updated all file references to match the new structure
- Created `postgresql_config.sh` under setup folder that:
  - Installs PostgreSQL using the official repository
  - Installs pgbouncer for connection pooling
  - Configures PostgreSQL with proper security settings:
    - Uses secure scram-sha-256 authentication instead of md5
    - Restricts direct PostgreSQL access to local connections only
    - Routes all external connections through pgbouncer
    - Configures firewall to enforce this connection policy
  - Sets up pgbouncer as middleware:
    - Uses a simplified, reliable configuration approach
    - Implements robust configuration verification without error messages
    - Includes automatic fallback to simpler configuration if needed
    - Features multiple verification methods for password hash extraction
  - Creates user-specified database
  - Configures client authentication based on user-defined IP ranges
  - Sets and secures PostgreSQL superuser password
  - Uses environment variables for all configuration settings
- Updated `init.sh` to include PostgreSQL installation and configuration
- Enhanced environment configuration:
  - Added PostgreSQL-specific settings to default.env and user.env.template
  - Added pgbouncer configuration settings
  - Added PostgreSQL superuser password management
  - Added SYSTEM_UPDATE and RUN_TESTS environment variables
  - Improved timezone configuration with proper variable handling
  - Set timezone to Asia/Hong_Kong
  - Enabled automatic test execution
- Improved logging and error handling:
  - Ensured clean, error-free logs during normal operation
  - Implemented graceful fallback mechanisms for configuration issues
  - Added verification steps for all critical components
  - Fixed timezone error by properly handling timezone variables
  - Added backward compatibility for legacy variable references

## Milestone 1
- Created an `init.sh` script that:
  - Updates the Ubuntu server silently
  - Sets up timezone directly from configuration
  - Checks if running as root
  - Loads environment variables
  - Provides proper initialization flow
- Created a `logger.sh` script with logging functions:
  - Implemented color-coded log levels (DEBUG, INFO, WARNING, ERROR)
  - Made log message timestamps bold
  - Made log messages white by default
  - Applied colors only to log level text
  - Added file logging capability
- Created environment configuration:
  - Added `default.env` with default configuration
  - Added `user.env.template` for user-specific settings
  - Implemented environment variable override logic
- Added utility functions:
  - Created `utilities.sh` with helper functions
  - Implemented `execute_silently` for quiet command execution
  - Added log file management
- Created general configuration:
  - Added system update functionality
  - Added timezone configuration



