#!/bin/bash
# security_config.sh - Enhanced Security Monitoring and Protection
# Part of Milestone 11
# This script implements fail2ban, geographic IP filtering, and WAF features

# Exit immediately if a command exits with a non-zero status
set -e

# Script directory
SECURITY_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SECURITY_LIB_DIR="$SECURITY_SCRIPT_DIR/../lib"

# Source required libraries
source "$SECURITY_LIB_DIR/logger.sh"
source "$SECURITY_LIB_DIR/utilities.sh"

# Install fail2ban
install_fail2ban() {
    log_info "Installing fail2ban for automated IP blocking..."
    
    # Check if fail2ban is already installed
    if command -v fail2ban-server >/dev/null 2>&1; then
        log_info "fail2ban is already installed"
        return 0
    fi
    
    # Update package index
    apt_update_with_retry 3 20
    
    # Install fail2ban
    if ! apt_install_with_retry "fail2ban" 3 20; then
        log_error "Failed to install fail2ban"
        return 1
    fi
    
    log_info "fail2ban installed successfully"
    return 0
}

# Configure fail2ban for nginx and ssh protection
configure_fail2ban() {
    log_info "Configuring fail2ban for enhanced security..."
    
    local fail2ban_dir="/etc/fail2ban"
    
    # Create fail2ban configuration directory
    mkdir -p "$fail2ban_dir/jail.d"
    mkdir -p "$fail2ban_dir/filter.d"
    
    # Create main jail configuration
    cat > "$fail2ban_dir/jail.d/postgresql-server.conf" << EOF
# PostgreSQL Server fail2ban configuration
# Generated by security_config.sh

[DEFAULT]
# Default ban time: 1 hour
bantime = 3600

# Find time: 10 minutes
findtime = 600

# Max retry attempts
maxretry = 3

# Ignore local IPs
ignoreip = 127.0.0.1/8 ::1 ${FAIL2BAN_WHITELIST_IPS:-10.0.0.0/8 172.16.0.0/12 192.168.0.0/16}

# Backend to use
backend = auto

# Ban action
banaction = iptables-multiport
banaction_allports = iptables-allports

# Email notifications
mta = sendmail
destemail = ${SECURITY_EMAIL:-root@localhost}
sender = ${SECURITY_EMAIL_SENDER:-fail2ban@localhost}
action = %(action_mwl)s

[sshd]
enabled = true
port = ssh
filter = sshd
logpath = /var/log/auth.log
maxretry = 3
bantime = 3600

[nginx-http-auth]
enabled = true
port = http,https
filter = nginx-http-auth
logpath = /var/log/nginx/error.log
maxretry = 3
bantime = 1800

[nginx-limit-req]
enabled = true
port = http,https
filter = nginx-limit-req
logpath = /var/log/nginx/error.log
maxretry = 5
bantime = 3600

[nginx-botsearch]
enabled = true
port = http,https
filter = nginx-botsearch
logpath = /var/log/nginx/access.log
maxretry = 2
bantime = 7200

[nginx-badbots]
enabled = true
port = http,https
filter = nginx-badbots
logpath = /var/log/nginx/access.log
maxretry = 1
bantime = 86400

[postgresql-auth]
enabled = true
port = 5432,6432
filter = postgresql-auth
logpath = /var/log/postgresql/postgresql-*.log
maxretry = 3
bantime = 3600
EOF

    # Create nginx-badbots filter
    cat > "$fail2ban_dir/filter.d/nginx-badbots.conf" << EOF
# Fail2ban filter for nginx bad bots
# Generated by security_config.sh

[Definition]
failregex = ^<HOST> -.*"(GET|POST|HEAD).*HTTP.*" (404|444) .*$
            ^<HOST> -.*"(GET|POST|HEAD) .*(wp-admin|wp-login|phpMyAdmin|phpmyadmin|admin|administrator).*HTTP.*" .*$
            ^<HOST> -.*"(GET|POST|HEAD) .*\.(php|asp|aspx|jsp|cgi|pl).*HTTP.*" .*$

ignoreregex =
EOF

    # Create nginx-botsearch filter
    cat > "$fail2ban_dir/filter.d/nginx-botsearch.conf" << EOF
# Fail2ban filter for nginx bot searches
# Generated by security_config.sh

[Definition]
failregex = ^<HOST> -.*"(GET|POST|HEAD) .*/(\?|&).*=(SELECT|UNION|INSERT|DELETE|UPDATE|DROP|CREATE|ALTER|EXEC).*HTTP.*" .*$
            ^<HOST> -.*"(GET|POST|HEAD) .*(\?|&).*(script|javascript|vbscript|onload|onerror).*HTTP.*" .*$
            ^<HOST> -.*"(GET|POST|HEAD) .*(\.\./){3,}.*HTTP.*" .*$

ignoreregex =
EOF

    # Create postgresql-auth filter
    cat > "$fail2ban_dir/filter.d/postgresql-auth.conf" << EOF
# Fail2ban filter for PostgreSQL authentication failures
# Generated by security_config.sh

[Definition]
failregex = .*FATAL:.*authentication failed for user.*from host "<HOST>".*
            .*FATAL:.*password authentication failed for user.*from host "<HOST>".*
            .*FATAL:.*no pg_hba.conf entry for host "<HOST>".*

ignoreregex =
EOF

    # Start and enable fail2ban
    systemctl enable fail2ban >/dev/null 2>&1
    systemctl start fail2ban >/dev/null 2>&1
    
    log_info "fail2ban configured and started successfully"
    return 0
}

# Install and configure geographic IP blocking
configure_geoip_blocking() {
    log_info "Setting up geographic IP filtering..."
    
    # Install geoip database
    if ! apt_install_with_retry "geoip-database geoip-bin" 3 20; then
        log_warn "Failed to install GeoIP database, but continuing"
        return 0
    fi
    
    # Create GeoIP blocking script
    cat > "/usr/local/bin/geoip-block.sh" << 'EOF'
#!/bin/bash
# GeoIP blocking script
# Generated by security_config.sh

# Countries to block (ISO 2-letter codes)
BLOCKED_COUNTRIES="${GEOIP_BLOCKED_COUNTRIES:-CN RU KP IR}"

# Create ipset for blocked countries
ipset create geoblock hash:net -exist

# Function to block country
block_country() {
    local country="$1"
    local geoip_file="/usr/share/GeoIP/GeoIPCountryWhois.csv"
    
    if [ -f "$geoip_file" ]; then
        # Extract IP ranges for the country and add to ipset
        grep "\"$country\"" "$geoip_file" | while read line; do
            start_ip=$(echo "$line" | cut -d, -f1 | tr -d '"')
            end_ip=$(echo "$line" | cut -d, -f2 | tr -d '"')
            # Convert IP range to CIDR (simplified approach)
            if [ -n "$start_ip" ] && [ -n "$end_ip" ]; then
                # Add individual IPs or ranges to ipset
                ipset add geoblock "$start_ip" -exist 2>/dev/null || true
            fi
        done
        echo "Blocked country: $country"
    fi
}

# Block specified countries
for country in $BLOCKED_COUNTRIES; do
    block_country "$country"
done

# Create iptables rule to block the ipset
iptables -I INPUT -m set --match-set geoblock src -j DROP 2>/dev/null || true

echo "GeoIP blocking applied for countries: $BLOCKED_COUNTRIES"
EOF

    chmod +x "/usr/local/bin/geoip-block.sh"
    
    # Create systemd service for GeoIP blocking
    cat > "/etc/systemd/system/geoip-block.service" << EOF
[Unit]
Description=GeoIP Country Blocking
After=network.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/geoip-block.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

    # Enable the service
    systemctl daemon-reload
    systemctl enable geoip-block.service >/dev/null 2>&1
    
    log_info "Geographic IP filtering configured"
    return 0
}

# Configure additional nginx security features
configure_nginx_security() {
    log_info "Configuring additional nginx security features..."
    
    # Check if nginx has http block to insert maps correctly
    local nginx_main_conf="/etc/nginx/nginx.conf"
    
    # Create nginx security configuration for http context
    if [ -f "$nginx_main_conf" ]; then
        # Insert maps at the end of http context if not already present
        if ! grep -q "map.*blocked_agent" "$nginx_main_conf"; then
            # Create a backup
            cp "$nginx_main_conf" "$nginx_main_conf.bak.security" 2>/dev/null || true
            
            # Find the last line of http context and insert before it
            local temp_file=$(mktemp)
            awk '
                /^http \{/ { in_http = 1 }
                in_http && /^\}/ && !done { 
                    print "    # Security maps added by security_config.sh"
                    print "    map $http_user_agent $rate_limit {"
                    print "        default \"\";"
                    print "        ~*(bot|crawler|spider|scraper) $binary_remote_addr;"
                    print "        ~*(wget|curl|python|php|perl) $binary_remote_addr;"
                    print "    }"
                    print ""
                    print "    map $http_user_agent $blocked_agent {"
                    print "        default 0;"
                    print "        ~*(nikto|nmap|sqlmap|w3af|acunetix|nessus|openvas) 1;"
                    print "        ~*(masscan|zmap|dirb|dirbuster|gobuster|hydra) 1;"
                    print "    }"
                    print ""
                    done = 1
                }
                { print }
            ' "$nginx_main_conf" > "$temp_file"
            
            if [ -s "$temp_file" ]; then
                mv "$temp_file" "$nginx_main_conf"
            else
                rm -f "$temp_file"
            fi
        fi
    fi
    
    # Create nginx security configuration for server context directives only
    cat > "/etc/nginx/conf.d/security.conf" << 'EOF'
# Enhanced nginx security configuration
# Generated by security_config.sh

# Hide nginx version
server_tokens off;

# Limit request size to prevent DoS
client_max_body_size 10M;
client_body_buffer_size 128k;
client_header_buffer_size 1k;
large_client_header_buffers 4 4k;

# Timeout settings
client_body_timeout 12;
client_header_timeout 12;
keepalive_timeout 15;
send_timeout 10;

# Real IP configuration (if behind CloudFlare or other proxy)
set_real_ip_from 103.21.244.0/22;
set_real_ip_from 103.22.200.0/22;
set_real_ip_from 103.31.4.0/22;
set_real_ip_from 104.16.0.0/12;
set_real_ip_from 108.162.192.0/18;
set_real_ip_from 131.0.72.0/22;
set_real_ip_from 141.101.64.0/18;
set_real_ip_from 162.158.0.0/15;
set_real_ip_from 172.64.0.0/13;
set_real_ip_from 173.245.48.0/20;
set_real_ip_from 188.114.96.0/20;
set_real_ip_from 190.93.240.0/20;
set_real_ip_from 197.234.240.0/22;
set_real_ip_from 198.41.128.0/17;
real_ip_header CF-Connecting-IP;
EOF

    # Create nginx security snippets
    mkdir -p "/etc/nginx/snippets"
    
    cat > "/etc/nginx/snippets/security-headers.conf" << 'EOF'
# Security headers snippet
# Generated by security_config.sh

add_header X-Frame-Options DENY always;
add_header X-Content-Type-Options nosniff always;
add_header X-XSS-Protection "1; mode=block" always;
add_header Referrer-Policy strict-origin-when-cross-origin always;
add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; connect-src 'self';" always;
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
add_header Permissions-Policy "geolocation=(), microphone=(), camera=()" always;
EOF

    cat > "/etc/nginx/snippets/block-exploits.conf" << 'EOF'
# Block common exploits
# Generated by security_config.sh

# Block user agents
if ($blocked_agent) {
    return 444;
}

# Block requests with no user agent
if ($http_user_agent = "") {
    return 444;
}

# Block requests with suspicious patterns
if ($args ~* "(union.*select|insert.*into|delete.*from|update.*set)" ) {
    return 444;
}

if ($args ~* "(javascript:|vbscript:|onload|onerror)" ) {
    return 444;
}

if ($request_uri ~* "(\.\./|/etc/passwd|/etc/shadow)" ) {
    return 444;
}

# Block common attack patterns in request body
if ($request_method = POST) {
    set $block_post 0;
    if ($http_content_type ~ "application/x-www-form-urlencoded") {
        set $block_post 1;
    }
    if ($http_content_type ~ "multipart/form-data") {
        set $block_post 1;
    }
}
EOF

    log_info "Additional nginx security features configured"
    return 0
}

# Configure security monitoring and alerting
configure_security_monitoring() {
    log_info "Setting up security monitoring and alerting..."
    
    # Create security monitoring script
    cat > "/usr/local/bin/security-monitor.sh" << 'EOF'
#!/bin/bash
# Security monitoring script
# Generated by security_config.sh

LOG_FILE="/var/log/security-monitor.log"
ALERT_EMAIL="${SECURITY_EMAIL:-root@localhost}"

# Function to send alert
send_alert() {
    local subject="$1"
    local message="$2"
    echo "[$(date)] SECURITY ALERT: $subject - $message" >> "$LOG_FILE"
    
    if command -v mail >/dev/null 2>&1; then
        echo "$message" | mail -s "SECURITY ALERT: $subject" "$ALERT_EMAIL" 2>/dev/null || true
    fi
}

# Check for suspicious activity
check_nginx_attacks() {
    local recent_attacks=$(tail -1000 /var/log/nginx/access.log 2>/dev/null | grep -E "(404|444)" | wc -l)
    if [ "$recent_attacks" -gt 50 ]; then
        send_alert "High number of 404/444 responses" "Detected $recent_attacks 404/444 responses in recent logs"
    fi
}

check_failed_logins() {
    local failed_ssh=$(tail -1000 /var/log/auth.log 2>/dev/null | grep "Failed password" | wc -l)
    if [ "$failed_ssh" -gt 10 ]; then
        send_alert "High number of SSH login failures" "Detected $failed_ssh failed SSH login attempts"
    fi
}

check_fail2ban_bans() {
    local recent_bans=$(fail2ban-client status 2>/dev/null | grep "Currently banned" | awk '{print $3}' || echo "0")
    if [ "$recent_bans" -gt 5 ]; then
        send_alert "High number of fail2ban bans" "Currently $recent_bans IPs are banned by fail2ban"
    fi
}

# Run checks
check_nginx_attacks
check_failed_logins
check_fail2ban_bans

echo "[$(date)] Security monitoring check completed" >> "$LOG_FILE"
EOF

    chmod +x "/usr/local/bin/security-monitor.sh"
    
    # Create cron job for security monitoring
    cat > "/etc/cron.d/security-monitor" << EOF
# Security monitoring cron job
# Generated by security_config.sh

# Run security monitoring every 15 minutes
*/15 * * * * root /usr/local/bin/security-monitor.sh >/dev/null 2>&1
EOF

    log_info "Security monitoring configured"
    return 0
}

# Main setup function
setup_security() {
    log_info "Setting up enhanced security monitoring and protection..."
    
    # Track installation status
    local fail2ban_success=false
    local geoip_success=false
    local nginx_security_success=false
    local monitoring_success=false
    
    # Install and configure fail2ban
    if install_fail2ban && configure_fail2ban; then
        fail2ban_success=true
    else
        log_error "fail2ban setup failed, but continuing"
    fi
    
    # Configure geographic IP blocking
    if configure_geoip_blocking; then
        geoip_success=true
    else
        log_error "GeoIP blocking setup failed, but continuing"
    fi
    
    # Configure nginx security features
    if configure_nginx_security; then
        nginx_security_success=true
    else
        log_error "Nginx security configuration failed, but continuing"
    fi
    
    # Configure security monitoring
    if configure_security_monitoring; then
        monitoring_success=true
    else
        log_error "Security monitoring setup failed, but continuing"
    fi
    
    # Restart services to apply configurations
    log_info "Restarting services to apply security configurations..."
    
    if [ "$fail2ban_success" = true ]; then
        systemctl restart fail2ban >/dev/null 2>&1 || log_warn "Failed to restart fail2ban"
    fi
    
    if [ "$nginx_security_success" = true ]; then
        # Test nginx configuration first
        if nginx -t >/dev/null 2>&1; then
            systemctl reload nginx >/dev/null 2>&1 || log_warn "Failed to reload nginx - trying restart"
            # If reload fails, try restart
            if ! systemctl status nginx >/dev/null 2>&1; then
                systemctl restart nginx >/dev/null 2>&1 && log_info "Nginx restarted successfully" || log_warn "Failed to restart nginx"
            fi
        else
            log_warn "Nginx configuration test failed - skipping reload to prevent service disruption"
            # Show the actual error for debugging
            log_warn "Nginx configuration error details:"
            nginx -t 2>&1 | while read line; do log_warn "$line"; done
        fi
    fi
    
    # Print setup summary
    log_info "-----------------------------------------------"
    log_info "SECURITY SETUP SUMMARY"
    log_info "-----------------------------------------------"
    
    if [ "$fail2ban_success" = true ]; then
        log_info "✓ fail2ban installation and configuration: SUCCESS"
    else
        log_error "✗ fail2ban installation and configuration: FAILED"
    fi
    
    if [ "$geoip_success" = true ]; then
        log_info "✓ Geographic IP filtering: SUCCESS"
    else
        log_error "✗ Geographic IP filtering: FAILED"
    fi
    
    if [ "$nginx_security_success" = true ]; then
        log_info "✓ Nginx security features: SUCCESS"
    else
        log_error "✗ Nginx security features: FAILED"
    fi
    
    if [ "$monitoring_success" = true ]; then
        log_info "✓ Security monitoring: SUCCESS"
    else
        log_error "✗ Security monitoring: FAILED"
    fi
    
    log_info "-----------------------------------------------"
    
    # Return success if at least fail2ban was configured
    if [ "$fail2ban_success" = true ]; then
        log_info "Enhanced security setup completed successfully"
        return 0
    else
        log_error "Security setup failed - fail2ban is required for basic protection"
        return 1
    fi
}

# If script is run directly, execute setup
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    setup_security
fi
